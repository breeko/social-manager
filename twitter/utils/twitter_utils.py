""" twitter_utils.py"""
import json
from typing import Callable, List

import requests
import tweepy
from bs4 import BeautifulSoup
from requests.utils import quote
from tweepy.api import API

MODEL_CHOICES = (
  ('gpt2', 'gpt2'),
  ('gpt2-xl', 'gpt2-xl'),
  ('gpt2-large', 'gpt2-large'),
  ('gpt2-medium', 'gpt2-medium'),
  ('html', 'html')
)

def generate_tweet(phrase: str, model: str) -> str:
  """ Generates a tweet based on a phrase and model """
  if model == "html":
    return generate_html(phrase)
  if model.startswith('gpt2'):
    return generate_hugging_face(phrase, model)
  return ''

def generate_html(phrase: str) -> str:
  """ Returns parsed expression generated by thoughts.sushant-kumar.com based on phrase """
  url = f"https://thoughts.sushant-kumar.com/{quote(phrase)}"
  response = requests.get(url)
  soup = BeautifulSoup(response.text, "html.parser")
  out = soup.blockquote.text.replace("\n", "")[1:-1]
  return out

def generate_hugging_face(phrase: str, model: str) -> str:
  """ valid models: gpt2, gpt2-xl, gpt2-large, gpt2-medium"""
  headers = {
      'Authorization': 'Bearer YOUR_ORG_OR_USER_API_TOKEN',
      'Content-Type': 'application/json',
  }
  data = f'"{phrase}"'
  raw = requests.post(f'https://api-inference.huggingface.co/models/{model}', headers=headers, data=data)
  try:
    response = json.loads(raw.text)
    return response[0].get('generated_text')
  except:
    return ""


def get_api(user: 'User') -> API:
  """ Returns an api object based on user credentials """
  auth = tweepy.OAuthHandler(user.api_key, user.api_secret)
  auth.set_access_token(user.api_access_token, user.api_token_secret)
  api = tweepy.API(auth)
  return api

def get_trends(user: 'User', geo_code: int = 23424977) -> List[str]:
  """ Returns trends in a given geo-code (default US) """
  api = get_api(user)
  trends = api.trends_available()
  trends = api.trends_place(geo_code)
  trends_names = [n.get('name') for n in trends[0]['trends']]
  return trends_names

def chunks(lst, chunk_size):
  """Yield successive n-sized chunks from lst."""
  for i in range(0, len(lst), chunk_size):
    yield lst[i:i + chunk_size]

def get_suggestions(
    user: 'User',
    hashtag: str,
    valid_user: Callable[['User'], bool],
    since: str,
    max_suggestions: int
  ) -> List[tweepy.models.User]:
  """ Returns friend suggestions based on current friends
    Input:
      user [User]: user to get api login
      hashtag [str]: hashtag to search
      valid_user [User => bool]: function to filter valid users
      max_suggestions [int]: maximum number of suggestions to return
    Output:
      users [List[tweepy.model.User]]: list of users that match valid_user
  """
  api = get_api(user)
  suggestions = []

  for tweet in tweepy.Cursor(api.search, q=hashtag, lang="en", since=since).items():
    if valid_user(tweet.user):
      suggestions.append(tweet.user)
    if len(suggestions) >= max_suggestions:
      break

  return suggestions

def create_valid_user(
    blacklist: str,
    followers_max: str,
    followers_min: str,
    friends_max: str,
    friends_min: str,
    followers_friend_ratio_min: str,
    followers_friend_ratio_max: str
  ):
  """ Returns a function that takes a user and returns whether the user is valid"""
  def valid_user(user: 'User') -> bool:
    return \
      (blacklist == '' or
       not any([w for w in blacklist.split(",") if w.lower() in user.description.lower()])) and \
      (followers_min == ''
       or user.followers_count >= int(followers_min)) and \
      (followers_max == ''
       or user.followers_count <= int(followers_max)) and \
      (friends_min == ''
       or user.friends_count >= int(friends_min)) and \
      (friends_max == ''
       or user.friends_count <= int(friends_max)) and \
      (followers_friend_ratio_min == ''
       or user.followers_count / user.friends_count >= float(followers_friend_ratio_min)) and \
      (followers_friend_ratio_max == ''
       or user.followers_count / user.friends_count <= float(followers_friend_ratio_max))
  return valid_user
